# 笔记规范

- 数据结构(分组)是一级标题;
- 题目是二级标题
- 接下来是解题思路(程序构建)
- 还有是可有可无的小细节
- 语言相关笔记可以一起写在最上边
- ==算法部分的学习,重点不是答案,而是从题目思考到答案的**过程**==

**目的(复习思路):**

以后看这道题的思路,然后想想代码是如何写的,想不清楚的地方就回去看

# 语言相关笔记

**关于封装**

`private`中的`result`也可以在`public`中引用,`result`是类变量

# 字符串

## 0046

```cpp
class Solution {
public:
    //构造next数组
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            //匹配失败-回退
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];		//回退的对象是j,所以应该是j在左边[注意不要写成j在等号右边],而找j是一句next数组的,又因为要回退到上一个数字,所以就要[j-1];之所以另一个版本的没有差一,是因为另一个版本比较的时候用的是[j+1]
            }
            //前缀匹配成功
            if (s[i] == s[j]) {
                j++;
            }
            //每一轮i循环的next此处的值的确定
            next[i] = j;
        }
    }
    
    //KMP算法
    int strStr(string haystack, string needle) {
        //约定,如果模式串是空的,那么返回0
        if (needle.size() == 0) {
            return 0;
        }
        //构造next数组,时间复杂度O(m)
        vector<int> next(needle.size());
        getNext(&next[0], needle);
        //开始匹配
        int j = 0;		//j是每轮i也要公用的,因为要记住模式串"走"到哪儿了
        for (int i = 0; i < haystack.size(); i++) {		//遍历文本串的每一个字符
            //匹配失败-回退,和next构造的思路是一样的
            while(j > 0 && haystack[i] != needle[j]) {	
                j = next[j - 1];
            }
            //匹配成功
            if (haystack[i] == needle[j]) {
                j++;
            }
            //匹配失败
            if (j == needle.size() ) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

**总结:**

要知道,在一个字符串中寻找是否出现子串是KMP最擅长的

### 总结

**双指针法**:	在数组，链表和字符串中很常用。

**从后往前操作**:很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。

**循环的改进**:当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章

**KMP**:前缀表

---

# 栈与队列

这里(CPP)的栈和队列不算是容器,而是**容器适配器**

### **stoll**

字符串类型转换

### duque

C++中deque(双向队列)是stack和queue默认的底层实现容器，deque是可以两边扩展的，而且deque里元素**并不是严格的连续分布**的。

## 优先队列

操作形似队列,本质是堆,堆就是完全二叉树

时间复杂度分析:每一次堆化是$O(\log n)$ ,n次堆化就是$O(n\log n)$ ,但是请注意i,堆化的次数最多是k次(因为维护的堆的元素个数就只有k,所以最终的时间复杂度就是$O(n\log k)$)

堆(优先队列)在cpp中是有实现的,针对这道题,需要做的是:**自定义一个比较器`operator`**(函数),然后初始化`priority_queue`

### **什么是pair**

`pair` 是 C++ 标准库中的一个模板类，用于存储一对数据。它可以存储两个不同类型的值，可以是相同类型的值，也可以是不同类型的值。

**使用**

```c++
p.first
p.second
```

### **unordered_map**

在创建的时候不需要初始化大小,是一个哈希表,他会动态调整.

## 感悟

这一章节里面的最后两道题,单调队列和优先级队列,都是主要维护的是一部分,而不是全部.这种维护一部分(需要部分)的思想需要注意,自己也要想到.

---



# 树

或许是我曾今记错了,树的遍历,如果用递归,代码表现上是非常简单的,并且前中后序遍历的差别几乎没有,但是如果使用迭代,代码的差别还是挺大的.

## **统一遍历法**

,如何定义要处理的节点?(什么样的节点就是要处理的?)

## **翻转二叉树:**

唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次**[为什么呢?我模拟了一下感觉也没有问题啊?]哦==我懂了,一开始的左节点,在中序的时候,会被换到右节点,然后这个会被翻转两次而另一个子节点没有能被翻转==√

## **最小深度:**

最大深度很容易理解，最小深度就不那么好理解，如图：

![111.二叉树的最小深度](https://code-thinking.cdn.bcebos.com/pics/111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.png)

这就重新审题了，题目中说的是：**最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\**注意是\**叶子节点**。

什么是叶子节点，左右孩子都为空的节点才是叶子节点！

这两道求深度的都比较适合后序遍历的递归思路(就是先处理左右子节点,然后在处理原来的节点的某些值)

## **完全二叉树的节点个数:**

==我有注意到题目给的root是数组形式的,又不是只给一个root的指针,那直接.size()不就解决了么?==

**细节部分**

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

完全二叉树（一）如图： ![222.完全二叉树的节点个数](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124092543662.png)

完全二叉树（二）如图： ![222.完全二叉树的节点个数1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124092634138.png)

可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。

**思路**

递归判断节点以及它的树是不是满二叉树,是就用公式计算节点个数,(判断细节是上面的)

## **平衡二叉树**

我感受不到前序后序的区别,但是根据深度和高度的定义,高度是节点到叶子节点的节点数,就应该是把该节点下面的节点全出栈以后在说高度+1,又感觉没毛病,但是自己写的时候,关于前序还是后序可能会比较懵.

## **二叉树的所有路径**

回溯和递归是一一对应的，有一个递归，就要有一个回溯

那么在如上代码中，**貌似没有看到回溯的逻辑，其实不然，回溯就隐藏在`traversal(cur->left, path + "->", result);`中的 `path + "->"`。** 每次函数调用完，path依然是没有加上"->" 的，这就是回溯了.

## 左叶子之和

子叶子判断是左右子节点为空,但是无法判断它是不是左叶子,所以**判断当前节点是不是左叶子是无法判断的，必须要通过节点的==父节点==来判断其左孩子是不是左叶子。**

## 路径累加和

不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用**递减**，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。

## 二叉搜索树的最小绝对差

**方法一**

就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。

**方法二**

中序遍历的时候直接计算

```
(只需要一个 pre)
代码中要取min,所以result初始化的时候应该是INT_MAX
pre一般初始化为NULL
private中的result也可以在public中引用,result是类变量
```

**方法三**

迭代,很难完全顺下来

```
while的循环条件有一个(cur!=NULL || !st.empty()),这是因为这个stack不是要存储所有的元素,中序遍历过后就扔掉了,有可能stack空的时候遍历并没有结束
循环内线判断cur是否NULL,整体分为两部分,中序遍历的规律,先走到最左下(这就是这里cur!=NULL的意义)
st.top()以后记得st.pop(),这次忘记了
```



## 二叉搜索树中的众数

题目给出是搜索树,就应该想一下猫腻在哪里

**方法一**

(如果不是搜索树)遍历一遍树(这一步是计数),然后排序,然后取元素

```
排序是对map的value排序,并没有直接的函数,需要转换成元素为pair的vector,写法是sort(vec.begin(),vec.end(),cmp),cmp函数需要自己定义

根据题目要求,如果众数不止一个的时候都要输出,需要把排序后的vector放进一个循环处理一下,注意第一个元素不需要和后面的元素的second一样

根据题目要求,如果众数不止一个的时候都要输出,所以返回的结果也是vector<int>

记得考虑root=NULL
```

**方法二**

针对是搜索树的情况,中序遍历,同时计数,同时比较是否出现最大值

```
众数有可能有多个,所以就需要初始化一个数组,与maxCount相等的都放进去,当遇到更大的maxCount的时候clear()result数组

pre的更新是每过一个节点都要进行的常规操作,因此应该写在判断的外面
```

## 二叉树的最近公共祖先

**思路**

回溯是天然的实现向上查找的好方法,后序遍历是天然的回溯,qp的出现到最近公共祖先的时候必然是一个在左一个在右(细品**最近**这个条件),(也有可能q是这个节点本身)

```
一个有意思的地方是后序回溯

一个是前面判断用root,后面判断用left,right
```

## 二叉搜索树的最近公共祖先

**思路**

我自己的思路是~~中序~~遍历[后来想了一下发现其实也不需要是中序遍历],判断每一个节点,当这个节点的值在两者之间的时候,就是最近的公共祖先

题解斯思路并不是运用遍历,因为已经有方向了,应该有目的的取找目标位置.就像原来的在二叉搜索树中寻找元素

## 二叉搜索树中的插入操作

**思路**

主要是插入操作需要父节点,递归设计合理(有返回值)的情况下,可以合理简化代码

## 删除二叉搜索树中的节点

**思路**

MINE:这个就比较麻烦了应该,主要是考虑如果删除了中间的节点,它下面的应该如何重构,重构思路去找中间最下面的节点,然后处理

## 修剪二叉搜索树

**思路**

有一种比较特殊的情况,所以应该后序的思路来考虑

```
要分清递归和递归调用
```

## 将有序数组转换为二叉搜索树

**思路**

我感觉二分处理,应该比较好

**官方**

本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间。

**注意**

不难写出`int mid = (left + right) / 2;`，**这么写其实有一个问题，就是数值越界，例如left和right都是最大int，这么操作就越界了，在二分法中尤其需要注意**,应该写成`int mid = left + ((right - left) / 2);`

```
主函数调用traversal(nums,0,nums.size())的时候,记得right的值一般是nums.size()-1,记得减一!
```

## 把二叉搜索树转换为累加树

**思路**

就是原来的遍历是从左往右,自己理解着写一个从右往左的

# 回溯

**综述**

**理解一**:回溯是递归的副产品,有递归就会有回溯

**理解二**:**回溯法解决的问题都可以抽象为树形结构**.回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度就构成了树的深度**。![回溯算法理论基础](https://ycw-bucket1.oss-cn-beijing.aliyuncs.com/20210130173631174.png)

**理解三**:什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

**理解四**:回溯的本质还是穷举,效率并不高,但是有些问题并没有办法高效.有些穷举,不回溯都写不出来

**回溯法解决的问题**

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

**算法模板框架**

```text
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 组合

**思路**

回溯

**理解**

其实不定义这两个全局变量也是可以的，把这两个变量放进递归函数的参数里，但函数里参数太多影响可读性，所以我定义全局变量了。

## 电话号码的字母组合

**思路**

1. 数字和字母如何映射---定义一个二维数组

   ```cpp
   const string letterMap[10] = {
       "", // 0
       "", // 1
       "abc", // 2
       "def", // 3
       "ghi", // 4
       "jkl", // 5
       "mno", // 6
       "pqrs", // 7
       "tuv", // 8
       "wxyz", // 9
   };
   ```

2. 回溯

## 组合总和

**思路**

**注意**

- **无限制重复被选取，吓得我赶紧想想 出现0 可咋办**，这道题没有0,但是这个点要想到,否则+的时候一直加0就没有尽头了

## 组合总和II

**注意**

1. 本题candidates 中的每个数字在每个组合中**只能使用一次**。(这里说的是每个数组,不是每种数字,比如`1`出现了三次,那这个组合的结果里面,`1`也可以出现三次)
2. 本题数组candidates的元素是**有重复**的

**思考**

```
本题目的去重,树的同层去重,而不是一颗树的同一支上去重,因为结果组合里面可以有重复元素,但是不可以有重复组合[这句话很重要,仔细理解]同层的变换是循环实现的,所以去重也应该是循环中的去重,所以应该传入一个人去重数组.

要把相同的元素挨到一起,所以要对digites排序,这样挨到一起就方便判断了

bool数组初始化方法:vector<bool> is_selected(nums.size(),false); 
```

## 分割回文串

**在代码里,索引就是切割线**

## 复原IP地址

```
const的不行insert,所以如果要insert,就不要加const
```

## 子集

```
注意循环中jinbacktracking的index,(有时候是循环变量)
```

## 子集II

和前面做过的一道题没有区别,注意的是树层去重

## 递增序列

```
不能排序,因为要找原先递增的序列,排序了就全是递增了

因为不能排序,为了同层去重,我们采用了一个used数组(unoedered_set<int>),如果目前这个元素在里面就continue(这也是一种剪枝),重要的是这个unordered_set是在每一层循环之前初始化的,是一个局部变量,所以回溯之后不需要处理它,它服务于整个循环,但是"不跨层"
```

## 全排列

```
排列就不是层级别的去重了,而是一个树枝上的去重,但是让我没想到的是,树枝上的去重也是在循环里进行的

这道题不再使用startIndex,而是使用一个bool的数组,标记每一个元素是否被使用过
```

## 全排列II

主要是进行去重

```
上面这个全排列中用到的方法就不适用了,因为used数组在回溯之后也是会回退的,这会造成一种"遗忘",出现重复数组

但是这道题可以用原来组合那里同一层去重的方法, 排序!

具体的去重思路:
nums的第一个元素,不进来
nums的连续的一样的元素的第一个"1",nums[i]==nums[i-1]不成立,所以会正常进入path,
	在这个分支下,下一个"1",这时候used[i-1]是true,这个不是"重",所以也要进入path;
	出来这个分支(也就是回溯以后),此时used[i]=false,然后同层走,轮到后面的"1"的时候,就满足了所有if中的条件,就应该跳过了(if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false))
```

对于ta说if中used=true也对的说法我是理解不了一点

## 重新安排行程

## N皇后

**思路**

本人认为,难点是数据的抽象和构建,棋盘是`vector<string>`(注意这是相当于二维的了,每个string代表一行,string里面的每个字符代表每一个格子),result就存放所有的可能结果.

**回溯过程**:回溯是每次往下走一行,循环是遍历每一行所有出现的可能,循环是要删除的,回溯是一个隐形的增减过程

**结果判断**:

1. 目的,判断这个格子是否正确,如果正确就放,然后回溯(继续);如果不能放就跳过,横着看下一个格子是否可能
2. 实现:只判断到目前位置的行和列,因为回溯导致一行上最多只能有一个,所以只需要判断三个方向,45°,135°,和列方向(写三个if)

## 接数独

有点想不通为什么是二维递归,先过了

---

# 贪心

## 分发饼干

大->大,但是有一个条件,就是必须满足饼干要大于等于小孩的胃口的时候才匹配

## 摆动序列

**这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点**,值得注意的是我们记录的是峰值,而不是result(最终结果),这两者还要转换一下的(这其中的一点点转换会在下文中表述到)

~~我自己原来的理解是遇到的第一个符合的就记录,然后不符合的删掉,这不太对,很多时候贪心不仅仅是第一个的概念,还要是某种程度上的最大或者是最小~~

以上是总体思路,除此之外,我们应该思考一些特殊情况,

- 上下坡中有平坡
  - 顶一个规定:有平坡的时候只算最右边的那个
- 数组首尾:
  - (对于最右边的数字来说)处理方法是result初始化为1,因为最右边的一个峰值是数不到的
  - (对于最左边的数字来说)特殊情况是只有两个数字的时候(这里的prediff和curdiff不好算,因为至少需要三个数字才能算),但是可以默认第一个数组左边还有一个和它相等的数字,这样根据平坡的处理策略,这第一个也会被算为一个峰值
- 单调中有平坡
  - (这算是一个对于特殊情况的特殊情况,因为1那个的平坡处理策略,导致这里的单调中的平坡也会被处理成为一个峰值,但这就错了)
  - 原因:
    - 之所以版本一会出问题，是因为我们实时更新了 prediff。[那么我们应该什么时候更新 prediff 呢？]
  - 解决策略:
    - 我们只需要在 这个坡度 摆动变化的时候，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。(也就是说每次往后走一次后,prediff变不变是看curdiff,嗯说的也不完全对,是综合未更新的prediff和更新后的curdiff共同决定prediff变不变)

## 最大子序和

**局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。**

## 买卖股票的最佳时机 II

**局部最优：收集每天的正利润，全局最优：求得最大利润**。

## 跳跃游戏

~~我的思路是倒着看,倒着看能到的,就视为是最后一个,然后再看这个格子能不能到~~

我的思路又不对,正确的思路是这样的:

**这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！**

**贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。

## 跳跃游戏II

**思路**

短期最远,合起来就是最远;但是这句话不是最表层的理解,而是要结合跳跃游戏I的覆盖范围的思路

**注意**

不是在最少的步数内走出最远的步数,而是以最小的步数走出最大的覆盖范围

**所以**

终极思路是每走一步,记录所走的步数,同时计算最大的范围,同时判断,当最大范围覆盖终点的时候结束

**感悟**

这个题看似是走路,但是你不是在真正走路,而是要判断**范围**

**错误**

```
if(nextDistance>=nums.size())  //错
if(nextDistance>=nums.size() - 1)
nextDistance是索引,所以右边的成分也应该对标索引也就是size()-1
```

## K次取反后最大化的数组和

**我的思路**

在k次循环内,先保证绝对值大的都变成＋的,然后改如果是k多余那就对最小的那个一直变,如果是少,那也是先把大的变正数了

**指正**

关于全是整数还要变号的情景缺乏考虑

**问题**

如何实现按照绝对值从大到小排序呢?

我的思路部分仅仅停留在想法上,**没有结合实践**

**实践1**

- 第二步：从前向后遍历，遇到负数将其变为正数，同时K--
- 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完

**实践2**

sort函数可以用自己定义的cmp函数进行排序,**true排**

## 加油站

我自己不是很有思路

**思路**

首先关键是想到`rest`数组,也就是`gas[i] - cost[i]`;

我们假设是从0开始走这个环,从start(索引)开始,对rest数组做和,当和小于0时,就不行了,就需要start从i+1开始(至于为什么是i+1,其实你可以理解为,如果只有一个数字,他是负数,那肯定不行,那在这个规则下,和的前一个加数只能是正数,加一个正的的结果都还是负的,那肯定就更不行了,又因为这个数组一定有唯一结果,所以不需要用环形数组的取余思想给它环起来)

**精妙**

精妙的地方在于上述的start开始,用了一个贪心的思想,

从代码实现上看,一次循环就搞定了

## 分发糖果

**我的思路**

能少就少,让目前的最少,需要多的时候,多一下

**错误**

忽略了上来就单调递减的情况,所以我的思路还是少了一方面,从哪里开始这个问题很重要

**实现**

实现上一定要从左小右再从右向左,有点没有想通

**理解**

积分数组和那个是脱钩的,所以通过两次循环挂钩

## 柠檬水找零

简单模拟,注意区分三种钱是不同的,

**实现**

为三种钱计数即可,然后写好每一种情况的判断

## 根据身高重建队列

看不懂题意,先过了

## 用最少数量的箭引爆气球

**我的思路**

贪心思路还是比较好想的,主要是实现没有思路

**疑问**

这里的贪心思想是有重叠,射箭就是可以的,而不需要思考重叠部分多不多

**实现**

如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remove气球，只要记录一下箭的数量就可以了。

注意一下这个sort,里面的cmp是自定义的,cmp比较的元素是连个`vector<int>`

## 无重叠区间

**思路**

排序(这个排序是按照左端或者是右端进行的),如果有重合就意味着是有下一段在上一段的结束之前就开始了

**实现**

这个代码的总体的逻辑和思路是一样的,但是代码是反着实现的

```cpp
class Solution {
public:
    // 按照区间右边界排序
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[1] < b[1];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.size() == 0) return 0;
        sort(intervals.begin(), intervals.end(), cmp);
        int count = 1; // 记录非交叉区间的个数
        int end = intervals[0][1]; // 记录区间分割点
        for (int i = 1; i < intervals.size(); i++) {
            if (end <= intervals[i][0]) {
                end = intervals[i][1];
                count++;
            }
        }
        return intervals.size() - count;
    }
};
```

## 划分字母区间

**注意**

就是每次划分的时候要实现“把其中涉及到的数字全部包含进去的意思”这一步不好想的

**实现**

`left`是用来计算的;`right`是用来计数的

## 合并区间

**注意**

这类与重叠区间有关的题目,需要注意的就是可以把开头和结尾看成两个部分,各自有对应需要处理的逻辑

**实现**

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> result;
        if (intervals.size() == 0) return result; // 区间集合为空直接返回
        // 排序的参数使用了lambda表达式
        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b){return a[0] < b[0];});

        // 第一个区间就可以放进结果集里，后面如果重叠，在result上直接合并
        result.push_back(intervals[0]); 

        for (int i = 1; i < intervals.size(); i++) {
            if (result.back()[1] >= intervals[i][0]) { // 发现重叠区间
                // 合并区间，只更新右边界就好，因为result.back()的左边界一定是最小值，因为我们按照左边界排序的
                result.back()[1] = max(result.back()[1], intervals[i][1]); 
            } else {
                result.push_back(intervals[i]); // 区间不重叠 
            }
        }
        return result;
    }
};
```

这个代码也值得多看一眼

## 单调递增的数字

**思路**

98，一旦出现strNum[i - 1] > strNum[i]的情况（非单调递增），首先想让strNum[i - 1]--，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。

**注意**

一定要从后往前,因为我们判断内的逻辑是修改前一个值,但是如果这样,那之前判断过的一组有可能不满足

**感悟**

这个思路的好处在于把数字和题目中给出的数字建立联系并分类,题目瞬间清晰

**反思**

(关于初始化),一开始的flag要初始化为`Nums.size()`,这是是和循环的判断条件相配合.

## 监控二叉树

**注意**

思考的时候应该是从下往上放,不放在叶节点,从下层开始思考,因为从下思考,顶多没有覆盖到一个父节点,但是如果从上往下可能会加很多个子节点.”因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。”

**实现**

主要是回溯和各种情况的模拟,以及最重要的是这个实现的思路,**状态代码**,

```cpp
// 版本一
class Solution {
private:
    int result;
    int traversal(TreeNode* cur) {

        // 空节点，该节点有覆盖
        if (cur == NULL) return 2;

        int left = traversal(cur->left);    // 左
        int right = traversal(cur->right);  // 右

        // 情况1
        // 左右节点都有覆盖
        if (left == 2 && right == 2) return 0;

        // 情况2
        // left == 0 && right == 0 左右节点无覆盖
        // left == 1 && right == 0 左节点有摄像头，右节点无覆盖
        // left == 0 && right == 1 左节点有无覆盖，右节点摄像头
        // left == 0 && right == 2 左节点无覆盖，右节点覆盖
        // left == 2 && right == 0 左节点覆盖，右节点无覆盖
        if (left == 0 || right == 0) {
            result++;
            return 1;
        }

        // 情况3
        // left == 1 && right == 2 左节点有摄像头，右节点有覆盖
        // left == 2 && right == 1 左节点有覆盖，右节点有摄像头
        // left == 1 && right == 1 左右节点都有摄像头
        // 其他情况前段代码均已覆盖
        if (left == 1 || right == 1) return 2;

        // 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解
        // 这个 return -1 逻辑不会走到这里。
        return -1;
    }

public:
    int minCameraCover(TreeNode* root) {
        result = 0;
        // 情况4
        if (traversal(root) == 0) { // root 无覆盖
            result++;
        }
        return result;
    }
};
```

https://code-thinking-1253855093.file.myqcloud.com/pics/%E8%B4%AA%E5%BF%83%E6%80%BB%E7%BB%93water.png

![img](https://ycw-bucket1.oss-cn-beijing.aliyuncs.com/%E8%B4%AA%E5%BF%83%E6%80%BB%E7%BB%93water.png)

---

---

# 动态规划

## 斐波那契数

**思路**

dp[i],就是第i个元素;递推公式天然给出来了.

**注意**

题意里面,`dp[0]=0`这和我们平常以为的是不一样的.

## 爬楼梯

类似上一个,需要自己思考到这是dp并且给出递推公式

## 使用最小花费爬楼梯

**注意**

理解上,这个题目涉及两个数组,一个是cost数组,一个是dp数组,cost是题目给的,dp是累计到i为止,一共的花销

## 不同路径

**注意**

一定要注意dp数组的含义

**实现**

我是用了`max(1,i-1)`,也可以先初始化第一行和第一列

## 不同路径II

**思路**

还是递推不变,在有障碍物的时候让这个位置的dp为0即可

**注意**

dp数组还是要自己创建的

**实现**

代码中的实现是一个全0初始化,vector的初始化需要注意,第一个参数是大小,第二个参数是每一个元素的`内容`

## ==整数拆分==

看不懂

## 不同的二叉搜索树

**思路**

dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

有2个元素的搜索树数量就是dp[2]。

有1个元素的搜索树数量就是dp[1]。

有0个元素的搜索树数量就是dp[0]。

所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

**感悟(反思)**

这道题的难点主要在于找递推关系,想到以不同节点为开头,然后再发现和每个左/右子树剩下的节点数量的关系

## 背包问题

**我的思考**

首先想贪心,这里用单位价值(总结/weight)作贪心,是不行的没有反例,比如说当有三个3|3.1(单价是1多一点点)和一个10|10(单价是1),但是背包容量是10的背包,单价的总结过并不是最好的

**实现**

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, bagweight;// bagweight代表行李箱空间

    cin >> n >> bagweight;

    vector<int> weight(n, 0); // 存储每件物品所占空间
    vector<int> value(n, 0);  // 存储每件物品价值

    for(int i = 0; i < n; ++i) {
        cin >> weight[i];
    }
    for(int j = 0; j < n; ++j) {
        cin >> value[j];
    }
    // dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化, 因为需要用到dp[i - 1]的值
    // j < weight[0]已在上方被初始化为0
    // j >= weight[0]的值就初始化为value[0]
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    for(int i = 1; i < weight.size(); i++) { // 遍历科研物品
        for(int j = 0; j <= bagweight; j++) { // 遍历行李箱容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j]; // 如果装不下这个物品,那么就继承dp[i - 1][j]的值
            else {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
            }
        }
    }
    cout << dp[n - 1][bagweight] << endl;

    return 0;
}
```

## 分割等和子集

**索引**

两个的和要求那等,那么每一个的和只能是sum的一半

**本题的本质是，能否把容量为 sum / 2的背包装满。**

**问题**

1. 在问题分析过程中,有一部分的逻辑我没有穿起来,那就是“既有一个 只能装重量为 sum / 2 的背包，商品为数字，这些数字能不能把 这个背包装满。”“一个数字只有一个维度，即 重量等于价值。”{这句话如何理解?模糊之中给我一种把2+2拆分成1+1+1+1的感觉,这是有点反直觉的(我的举例非常的抽象,而且我自己理解的也不是很彻底 )}

**实现**

- DP数组含义(非常难,后续再仔细理解啊)

  - 01背包中，dp[j] 表示： 容量（所能装的重量）为j的背包，所背的物品价值最大可以为dp[j]。

    如果背包所载重量为target， dp[target]就是装满 背包之后的总价值，因为 本题中每一个元素的数值既是重量，也是价值，所以，当 dp[target] == target 的时候，背包就装满了。

    有录友可能想，那还有装不满的时候？

    拿输入数组 [1, 5, 11, 5]，举例， dp[7] 只能等于 6，因为 只能放进 1 和 5。

    而dp[6] 就可以等于6了，放进1 和 5，那么dp[6] == 6，说明背包装满了。

- 加上了同样的空间优化(滚动数组)



**问题**

我的思路没有问题,确实是j >= nums[i]应该放在if中,但是要注意结合这道题的实现方法,用的是滚动数组,==滚动数组不变就是一种更新==,所以这里出现j >= nums[i]以后,前面的就不用更新了(这部分有误解主要是滚动数组的实现没有理解的很深刻)

## 最后一块石头的重量II

**我的思路**

~~这一组石头的和sum有一个sum/2,如果这二分之一内部相消,就会导致最后留下大的,如果以sum/2为界限,左边的消右边的就不会有问题,~~但是这道题其实也不用想这个二分之一,因为贪心来看的话,只要你是最小的去消解最大的,就一定是不亏的,排个序然后双指针消就行了

**思路**

人家用的是DP而且几乎和上一道一摸一样,就是最后加了一部处理,不多细看了

## 目标和

# 单调栈

## 每日温度

**索引**

输出额内容暗含大小相关(无法一开始对序列排序)

虽然说,这道题目的问题是在问到达下一个(满足要求的)元素的距离,实则在问下一个(满足要求的)元素的索引(索引出来了减一下就是答案了)所以我们接下来思考如何求出下一个元素的索引(更效率的方式)

那有同学就问了，我怎么能想到用单调栈呢？ 什么时候用单调栈呢？

==**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**==。时间复杂度为O(n)。

我们求的就是每一个位置(或者说元素)对应的索引,所以如果这个位置的索引我们就出来,就不需要让它待在栈里面了,弹出.具体实现在下.

**实现**

把现在这个元素的索引放进栈,然后这个元素与下一个元素比大小,如果下一个元素大,那上一个元素的结果就找到了,可以弹出,如果下一个元素小,就也放进来,那这个作为栈顶比较.

并且,如果是这样的话,下面的元素一定比上一个大,这样也保证不会有错误(模拟一下就清楚了)

还有一点需要注意的是我自己思考的时候忘记了两个元素相等的情况,这个也要想一下,然后发现它可以归到`<上一个元素`的情况

```cpp
// 版本一
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        // 递增栈
        stack<int> st;
        vector<int> result(T.size(), 0);
        st.push(0);
        for (int i = 1; i < T.size(); i++) {
            if (T[i] < T[st.top()]) {                       // 情况一
                st.push(i);
            } else if (T[i] == T[st.top()]) {               // 情况二
                st.push(i);
            } else {
                while (!st.empty() && T[i] > T[st.top()]) { // 情况三
                    result[st.top()] = i - st.top();
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};
```

## ==下一个更大元素 I==

**索引**

还是一样的,找后面出现的大的值,(应该遍历`nums2`,多一个判断,就是判断所针对的元素在不在`nums1`里面,这个应该是循环里面的第一个部分

**实现**

先判断是否在子集里面,如果不在就`continue`

**细节**

unordered_map在判断元素是否存在的时候,可以count(这个函数本身是判断对应元素有几个,但是umap不允许有重复元素,所以如果`nums.count(i)>0`表示的就是元素存在)

## 下一个更大元素II

**索引**

就是把原来的数组并一个在后面,再走一遍,相当于是循环了

**实现**

当然可以真的拼一个在后面,但是也可以换一个方法,就是遍历两边原来的数组{我自己想到的方法是i对size取余,然后i的范围设置在两个size内}

## 接雨水

**为什么没想到**

建模能力不足,我没有想到如此建模就能解决这个问题

### 暴力

**索引**

按照列来计算,每一列能有几个水,取决于min(左边最高,右边最高),这就需要用循环硬写了(这里的循环找两边的最大值也是要用双指针的,只不过低效在于每一个位置上都要双指针过一篇全部数组,妥妥的$O(n^2)$)

### 双指针

**索引**

在暴力的思路基础上做改进,有限次的遍历就记录所有的左边/右边最大,

**实现**

- 即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);

  从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);

  这个方法虽然叫做双指针,但是也只是理解的时候用双指针的思路,但是实现的时候还是用的他们的传递关系

### 单调栈

**索引**

通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。