# 算法笔记重构

## **设计范式**

算法中的**技巧性工具**或**优化方法**，它们通常被归类到更广泛的**数据结构与算法设计范式**中。这些方法的核心目标是通过特定的预处理或操作方式，优化某些常见问题的计算效率。它们不是独立的算法类别，而是服务于多种算法问题（如数组、字符串处理）的实用技术。

### 相关范式(工具/技巧)

**滑动窗口**

- **所属领域**：通常归于**双指针技术**或**窗口类算法**，是动态调整范围的一种方法。
- **本质**：通过维护一个连续的“窗口”并在数组或字符串上滑动，避免重复计算。
- **典型应用**：字符串匹配、子数组问题。
- **复杂度优化**：从 O（n²） 降到 O（n） 或 O（n log n）。

**前缀和**

- **所属领域**：属于**预处理技术**或**累积计算方法**，常用于数组的区间查询。
- **本质**：通过预先计算累积和，将区间和的查询从 O（n） 优化到 O（1）。
- **典型应用**：区间和查询、子数组和统计。
- **复杂度优化**：预处理 O（n），查询 O（1）。

**双指针（Two Pointers）**

- **特点**：使用两个指针（如快慢指针、左右指针）遍历数据结构，动态调整范围。
- **与滑动窗口的关系**：滑动窗口是双指针的一种特殊形式，窗口大小可以固定或动态变化。
- **示例**：
  - 快慢指针：找链表中的环（LeetCode 141）。
  - 左右指针：求数组中和为目标值的两个数（LeetCode 1）。
- **适用场景**：有序数组、链表、字符串。

**差分数组（Difference Array）**

- **特点**：通过记录数组相邻元素的差值，支持快速修改区间值并重建原数组。
- **与前缀和的关系**：差分是前缀和的“逆操作”，两者常结合使用。
- **示例**：区间加减作（LeetCode 370）。
- **适用场景**：频繁修改区间的场景。

**二分查找（Binary Search）**

- **特点**：在有序数据中通过折半查找快速定位目标。
- **类似之处**：像滑动窗口一样优化搜索范围，但适用于静态有序数据。
- **示例**：找数组中某个值的下标（LeetCode 704）。
- **适用场景**：有序数组或单调性问题。

**分治法（Divided and Conquer）**

- **特点**：将问题分解为小规模子问题，分别解决后合并。
- **类似之处**：像前缀和一样通过预处理分担计算压力。
- **示例**：归并排序、快速排序。
- **适用场景**：递归分解问题。

**动态规划的优化技巧（如状态压缩、前缀和优化）**

- **特点**：在动态规划中用前缀和或滚动数组减少重复计算。
- **与前缀和的关系**：前缀和常用于 DP 的状态转移优化。
- **示例**：背包问题中用前缀和加速。
- **适用场景**：需要累计信息的 DP 问题。

**单调栈/单调队列（Monotonic Stack/Queue）**

- **特点**：维护一个单调递增或递减的结构，快速找到符合条件的元素。
- **与滑动窗口的关系**：单调队列常用于固定窗口的最大值/最小值问题。
- **示例**：找数组中每个元素左侧第一个比它小的值（LeetCode 739）。
- **适用场景**：需要动态维护极值的场景。

**==哈希表==（Hash Map）辅助计数**

- **特点**：通过记录元素出现次数或状态，加速查找和统计。
- **与前缀和的关系**：前缀和常与哈希表结合统计和为某值的子数组。
- **示例**：两数之和（LeetCode 1）、和为 K 的子数组（LeetCode 560）。
- **适用场景**：需要快速查找或计数。

**==树状数组==/线段树（Fenwick Tree/Segment Tree）**

- **特点**：高效处理动态区间查询和修改。
- **与前缀和的关系**：前缀和适用于静态数组，树状数组和线段树支持动态更新。
- **示例**：区间和查询与更新（LeetCode 307）。
- **适用场景**：动态数组的区间作。

# 数组

https://file.kamacoder.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png

## 理论基础

- **数组下标都是从0开始的。**
- **数组内存空间的地址是连续的**

正是**因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。**

**数组的元素是不能删的，只能覆盖**

## 二分查找

**索引[思考索引]**

1. 数组有序
2. 无重复元素

**注意[容易想不清/忽略/写错]**

- 区间(就是判断的左右下标的标准)

**实现[代码相关的细节/想不到的/容易忽略的如此写的真正深意]**

- right的初始化注意`size()-1`
- middle计算,注意用防止溢出的个数`(left+(right-left)) / 2`
- left/right的更新要与区间的设置规则想对应

**其他**

有一个循环不变量原则,但是我觉得这是一种思想,我们在写的时候可能都分不清谁是循环量,这个是需要先认知到的,那个是循环量,在控制它在程序循环中不变

## 移除元素

**索引**

快慢指针法{不仅是可以把需要遍历两边的改成一遍,还可以同时得到许多有用的结果,快慢的本质是实现一种跳过}

## 有序数组的平方

**索引**

双指针法{这种双指针是从数组的两边开始的,那必然是因为这个数组是由一定规律的}

## 长度最小的子数组

**索引**

滑动窗口

- 数组或字符串中的**连续子序列**
- 别适用于数组、字符串等线性结构，因为它依赖于连续性

优化展示(用滑动窗口如何优化算法了?)

- 从“枚举所有子串”优化到“滑动窗口找符合条件的子串”

相关解释(这个为什么不用担心漏掉东西)

- 因为要求的是**连续**(来不及详细论证,但是根据这个自己感悟)

**实践**

```cpp
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

- 三目运算符的表达式
- result初始化为INT32_MAX,并且相应的在return的时候如此修正
- 代码相比于思路更加的集成,需要仔细与滑动窗口的画面对应

## ==螺旋矩阵II==

**索引**

- 这道题就是一个模拟题,一看上来没有思路(或者你有思路也有可能是错的,所以应该先自己在草稿纸上画一画,模拟几种情况,然后可能就会发现规律==如果没有发现,或者发现的不对呢?我也不知道啊,感觉像以前写数学题,你不会就是不会了==),但是为了防止自己的思路无辜试错,应该注意哪些写代码的原则(循环不变量)
- 这里模拟的本质是按数字的顺序放进去,也就是说你放的顺序就是1,2,3,4......,

**实践**

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j; j < n - offset; j++) {
                res[i][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 1;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

代码浑然一体,牵一发而动全身,==多看==

## 区间和

**索引**

维护一个前缀和数组

- 问题涉及连续子数组的属性

- 频繁查询区间和

- 题目有“累计”或“范围统计”的特征

- (什么时候不适用?)如果数据频繁修改（比如增删元素），前缀和维护成本高，可能需要用线段树或树状数组。

- 举例解释为什么前缀和有用(以及如何使用):

  如果，我们想统计，在vec数组上 下标 2 到下标 5 之间的累加和，那是不是就用 p[5] - p[1] 就可以了。

**实践**

```cpp
int main() {
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    vector<int> p(n);
    int presum = 0;
    for (int i = 0; i < n; i++) {
        scanf("%d", &vec[i]);
        presum += vec[i];
        p[i] = presum;
    }

    while (~scanf("%d%d", &a, &b)) {
        int sum;
        if (a == 0) sum = p[b];
        else sum = p[b] - p[a - 1];
        printf("%d\n", sum);
    }
}
```

##  开发商购买土地

==看不懂了==

# 链表

## 理论基础

### 分类

- 单链表
- 双链表(双向索引)
- 循环链表(首尾相连,可以解决<u>约瑟夫环问题</u>)

### 存储

内存中存储不连续

### 定义

```cpp
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```

**关于C++**

我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。

但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：

通过自己定义构造函数初始化节点：

```cpp
ListNode* head = new ListNode(5);
```

使用默认构造函数初始化节点：

```cpp
ListNode* head = new ListNode();
head->val = 5;
```

所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！

### 理解

- 删除节点:前后连接上跳过它
- 添加节点:也是修改连接
- 总结:相比于数组,增删快,查询慢,(内存不连续)

## 移除链表元素

**感悟**

在单链表中移除头结点 和 移除其他节点的操作方式是不一样，其实在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。

==链表中的头节点和后序的操作都不太一样,需要单独处理==(也可以设置一个虚拟头节点,但是如果这样的话,return 头结点的时候，别忘了 `return dummyNode->next;`， 这才是新的头结点)

**实践**

不需要双指针的,`cur->next->val == val`"往后多看一眼"就行了

```
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 删除头结点
        while (head != NULL && head->val == val) { // 注意这里不是if
            ListNode* tmp = head;
            head = head->next;
            delete tmp;
        }

        // 删除非头结点
        ListNode* cur = head;
        while (cur != NULL && cur->next!= NULL) {		//cur != NULL这一步就是在处理头节点为null的情况,只有这一种情况
            if (cur->next->val == val) {
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        return head;
    }
};

//使用虚拟头节点
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方便后面做删除操作
        ListNode* cur = dummyHead;
        while (cur->next != NULL) {
            if(cur->next->val == val) {
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        head = dummyHead->next;			//如果使用虚拟头节点,返回的时候记得做相关处理
        delete dummyHead;
        return head;			
    }
};

//递归
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 基础情况：空链表
        if (head == nullptr) {
            return nullptr;
        }

        // 递归处理
        if (head->val == val) {
            ListNode* newHead = removeElements(head->next, val);
            delete head;
            return newHead;
        } else {
            head->next = removeElements(head->next, val);
            return head;
        }
    }
};
```

## 设计链表

就是纯数据结构,做这种的时候,自己最好在旁边画一个示意图

**注意**

需要注意开始的索引是1还是0,

## 翻转链表

**实践**

- pre和cur只完成翻转操作,实现“找不到前一个“这个问题,但是改变指针的下一个要如何找呢?要用一个temp先记住,(相当于是三个指针了)
- 还有一个值得注意的就是这个赋值的顺序
- 模拟的时候一定先确定好初态,这还涉及到初始化的设计,初始化的pre要是null

## 两两交换链表中的节点

链表这部分的题目主要就是一个交换,模板就是

1. 使用虚拟头节点
2. 多几个指针
3. 搞清楚指针先后顺序(我认为可以拿上铅笔和纸画一画,都模拟一下看哪个好)

## 链表相交

**索引**

末端对齐(天啊,我为什么没有想到)

# 做题

## 数据类型

int的上限是$2^{31}$,大约等于$2 \times 10^9$(前者稍稍大一点)

## IO

1. `cout << nums << endl;`

   `nums` 是一个二维 `vector`，不能直接使用 `cout` 输出。若要输出二维 `vector`，需通过嵌套循环遍历每个元素。

2. 