# 算法笔记重构

## 算法思维

想清楚：**我为什么会卡住？**

是因为思路没拓展？不会拆分？不了解数据结构？对复杂度没概念？

 **建议：** 每次遇到新题，至少逼自己想**10分钟**，用以下问题问自己：

```
markdownCopyEdit1. 有没有最直接的暴力解？（不要怕，先写出来）
2. 会不会超时？大概什么复杂度？
3. 有没有能拆分成两个部分的结构？（分治、分组）
4. 有没有能用哈希表、双指针、前缀和、排序优化的地方？
5. 这题和我做过的哪道题像？能借鉴吗？
```

## **设计范式**

算法中的**技巧性工具**或**优化方法**，它们通常被归类到更广泛的**数据结构与算法设计范式**中。这些方法的核心目标是通过特定的预处理或操作方式，优化某些常见问题的计算效率。它们不是独立的算法类别，而是服务于多种算法问题（如数组、字符串处理）的实用技术。

### 相关范式(工具/技巧)

**滑动窗口**

- **所属领域**：通常归于**双指针技术**或**窗口类算法**，是动态调整范围的一种方法。
- **本质**：通过维护一个连续的“窗口”并在数组或字符串上滑动，避免重复计算。
- **典型应用**：字符串匹配、子数组问题。
- **复杂度优化**：从 O（n²） 降到 O（n） 或 O（n log n）。

**前缀和**

- **所属领域**：属于**预处理技术**或**累积计算方法**，常用于数组的区间查询。
- **本质**：通过预先计算累积和，将区间和的查询从 O（n） 优化到 O（1）。
- **典型应用**：区间和查询、子数组和统计。
- **复杂度优化**：预处理 O（n），查询 O（1）。

**双指针（Two Pointers）**

- **特点**：使用两个指针（如快慢指针、左右指针）遍历数据结构，动态调整范围。
- **与滑动窗口的关系**：滑动窗口是双指针的一种特殊形式，窗口大小可以固定或动态变化。
- **示例**：
  - 快慢指针：找链表中的环（LeetCode 141）。
  - 左右指针：求数组中和为目标值的两个数（LeetCode 1）。
- **适用场景**：有序数组、链表、字符串。

**差分数组（Difference Array）**

- **特点**：通过记录数组相邻元素的差值，支持快速修改区间值并重建原数组。
- **与前缀和的关系**：差分是前缀和的“逆操作”，两者常结合使用。
- **示例**：区间加减作（LeetCode 370）。
- **适用场景**：频繁修改区间的场景。

**二分查找（Binary Search）**

- **特点**：在有序数据中通过折半查找快速定位目标。
- **类似之处**：像滑动窗口一样优化搜索范围，但适用于静态有序数据。
- **示例**：找数组中某个值的下标（LeetCode 704）。
- **适用场景**：有序数组或单调性问题。

**分治法（Divided and Conquer）**

- **特点**：将问题分解为小规模子问题，分别解决后合并。
- **类似之处**：像前缀和一样通过预处理分担计算压力。
- **示例**：归并排序、快速排序。
- **适用场景**：递归分解问题。

**动态规划的优化技巧（如状态压缩、前缀和优化）**

- **特点**：在动态规划中用前缀和或滚动数组减少重复计算。
- **与前缀和的关系**：前缀和常用于 DP 的状态转移优化。
- **示例**：背包问题中用前缀和加速。
- **适用场景**：需要累计信息的 DP 问题。

**单调栈/单调队列（Monotonic Stack/Queue）**

- **特点**：维护一个单调递增或递减的结构，快速找到符合条件的元素。
- **与滑动窗口的关系**：单调队列常用于固定窗口的最大值/最小值问题。
- **示例**：找数组中每个元素左侧第一个比它小的值（LeetCode 739）。
- **适用场景**：需要动态维护极值的场景。

**==哈希表==（Hash Map）辅助计数**

- **特点**：通过记录元素出现次数或状态，加速查找和统计。
- **与前缀和的关系**：前缀和常与哈希表结合统计和为某值的子数组。
- **示例**：两数之和（LeetCode 1）、和为 K 的子数组（LeetCode 560）。
- **适用场景**：需要快速查找或计数。

**==树状数组==/线段树（Fenwick Tree/Segment Tree）**

- **特点**：高效处理动态区间查询和修改。
- **与前缀和的关系**：前缀和适用于静态数组，树状数组和线段树支持动态更新。
- **示例**：区间和查询与更新（LeetCode 307）。
- **适用场景**：动态数组的区间作。

# 数组

https://file.kamacoder.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png

## 理论基础

- **数组下标都是从0开始的。**
- **数组内存空间的地址是连续的**

正是**因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。**

**数组的元素是不能删的，只能覆盖**

## 二分查找

**索引[思考索引]**

1. 数组有序
2. 无重复元素

**注意[容易想不清/忽略/写错]**

- 区间(就是判断的左右下标的标准)

**实现[代码相关的细节/想不到的/容易忽略的如此写的真正深意]**

- right的初始化注意`size()-1`
- middle计算,注意用防止溢出的个数`(left+(right-left)) / 2`
- left/right的更新要与区间的设置规则想对应

**其他**

有一个循环不变量原则,但是我觉得这是一种思想,我们在写的时候可能都分不清谁是循环量,这个是需要先认知到的,那个是循环量,在控制它在程序循环中不变

## 移除元素

**索引**

快慢指针法{不仅是可以把需要遍历两边的改成一遍,还可以同时得到许多有用的结果,快慢的本质是实现一种跳过}

## 有序数组的平方

**索引**

双指针法{这种双指针是从数组的两边开始的,那必然是因为这个数组是由一定规律的}

## 长度最小的子数组

**索引**

滑动窗口

- 数组或字符串中的**连续子序列**
- 别适用于数组、字符串等线性结构，因为它依赖于连续性

优化展示(用滑动窗口如何优化算法了?)

- 从“枚举所有子串”优化到“滑动窗口找符合条件的子串”

相关解释(这个为什么不用担心漏掉东西)

- 因为要求的是**连续**(来不及详细论证,但是根据这个自己感悟)

**实践**

```cpp
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

- 三目运算符的表达式
- result初始化为INT32_MAX,并且相应的在return的时候如此修正
- 代码相比于思路更加的集成,需要仔细与滑动窗口的画面对应

## ==螺旋矩阵II==

**索引**

- 这道题就是一个模拟题,一看上来没有思路(或者你有思路也有可能是错的,所以应该先自己在草稿纸上画一画,模拟几种情况,然后可能就会发现规律==如果没有发现,或者发现的不对呢?我也不知道啊,感觉像以前写数学题,你不会就是不会了==),但是为了防止自己的思路无辜试错,应该注意哪些写代码的原则(循环不变量)
- 这里模拟的本质是按数字的顺序放进去,也就是说你放的顺序就是1,2,3,4......,

**实践**

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j; j < n - offset; j++) {
                res[i][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 1;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

代码浑然一体,牵一发而动全身,==多看==

## 区间和

**索引**

维护一个前缀和数组

- 问题涉及连续子数组的属性

- 频繁查询区间和

- 题目有“累计”或“范围统计”的特征

- (什么时候不适用?)如果数据频繁修改（比如增删元素），前缀和维护成本高，可能需要用线段树或树状数组。

- 举例解释为什么前缀和有用(以及如何使用):

  如果，我们想统计，在vec数组上 下标 2 到下标 5 之间的累加和，那是不是就用 p[5] - p[1] 就可以了。

**实践**

```cpp
int main() {
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    vector<int> p(n);
    int presum = 0;
    for (int i = 0; i < n; i++) {
        scanf("%d", &vec[i]);
        presum += vec[i];
        p[i] = presum;
    }

    while (~scanf("%d%d", &a, &b)) {
        int sum;
        if (a == 0) sum = p[b];
        else sum = p[b] - p[a - 1];
        printf("%d\n", sum);
    }
}
```

##  开发商购买土地

==看不懂了==

# 链表

## 理论基础

### 分类

- 单链表
- 双链表(双向索引)
- 循环链表(首尾相连,可以解决<u>约瑟夫环问题</u>)

### 存储

内存中存储不连续

### 定义

```cpp
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```

**关于C++**

我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。

但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：

通过自己定义构造函数初始化节点：

```cpp
ListNode* head = new ListNode(5);
```

使用默认构造函数初始化节点：

```cpp
ListNode* head = new ListNode();
head->val = 5;
```

所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！

### 理解

- 删除节点:前后连接上跳过它
- 添加节点:也是修改连接
- 总结:相比于数组,增删快,查询慢,(内存不连续)

## 移除链表元素

**感悟**

在单链表中移除头结点 和 移除其他节点的操作方式是不一样，其实在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。

==链表中的头节点和后序的操作都不太一样,需要单独处理==(也可以设置一个虚拟头节点,但是如果这样的话,return 头结点的时候，别忘了 `return dummyNode->next;`， 这才是新的头结点)

**实践**

不需要双指针的,`cur->next->val == val`"往后多看一眼"就行了

```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 删除头结点
        while (head != NULL && head->val == val) { // 注意这里不是if
            ListNode* tmp = head;
            head = head->next;
            delete tmp;
        }

        // 删除非头结点
        ListNode* cur = head;
        while (cur != NULL && cur->next!= NULL) {		//cur != NULL这一步就是在处理头节点为null的情况,只有这一种情况
            if (cur->next->val == val) {
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        return head;
    }
};

//使用虚拟头节点
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方便后面做删除操作
        ListNode* cur = dummyHead;
        while (cur->next != NULL) {
            if(cur->next->val == val) {
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        head = dummyHead->next;			//如果使用虚拟头节点,返回的时候记得做相关处理
        delete dummyHead;
        return head;			
    }
};

//递归
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 基础情况：空链表
        if (head == nullptr) {
            return nullptr;
        }

        // 递归处理
        if (head->val == val) {
            ListNode* newHead = removeElements(head->next, val);
            delete head;
            return newHead;
        } else {
            head->next = removeElements(head->next, val);
            return head;
        }
    }
};
```

## 设计链表

就是纯数据结构,做这种的时候,自己最好在旁边画一个示意图

**注意**

需要注意开始的索引是1还是0,

## 翻转链表

**实践**

- pre和cur只完成翻转操作,实现“找不到前一个“这个问题,但是改变指针的下一个要如何找呢?要用一个temp先记住,(相当于是三个指针了)
- 还有一个值得注意的就是这个赋值的顺序
- 模拟的时候一定先确定好初态,这还涉及到初始化的设计,初始化的pre要是null

## 两两交换链表中的节点

链表这部分的题目主要就是一个交换,模板就是

1. 使用虚拟头节点
2. 多几个指针
3. 搞清楚指针先后顺序(我认为可以拿上铅笔和纸画一画,都模拟一下看哪个好)

## 链表相交

### **索引**

末端对齐(如何想到?)

这是经典的「链表相交」问题，核心思路就是——**对齐两个链表的末端**，为什么会想到「末端对齐」呢？我来带你分析一下思路的演变过程：

------

1️⃣ 首先理解什么叫「相交」

链表相交的本质是两个链表在某个节点之后完全重合（共享一段内存）。也就是说：

- 从相交节点开始，两个链表的 `next` 都是相同的。
- 因此，**从尾部往前看**，两个链表尾巴的部分是相同的。

这时候，直觉上就会想到，如果能从尾巴同时开始遍历，马上就能找到相交点。但链表是单向的，无法倒着走。

**总结**——为什么这思路高级且自然？

✅ 因为「走完自己再走对方」的策略，本质上让两人「末端对齐」了。
✅ 解决了链表长度不一样，无法同步比较的问题。
✅ 不需要多余空间，O(1) 复杂度。

### **实现**

以下的实现是ai给出来的,随想率中的是先循环一遍算出两个链表的长度,然后通过移动`m-n`实现末端对其再一起移动

2️⃣ 转换思路：既然不能倒着走，那就「想办法让两个指针同时走到相同距离」

假设：

- 链表 A 长度为 `m`
- 链表 B 长度为 `n`
- 公共部分长度为 `c`

如果让两个人分别从 `headA` 和 `headB` 出发，直接走，很可能一边先走完，另一边还剩一截，根本无法比较相等。

怎么办？**思考如何让两个人同时走到相交区开始的地方。**

------

3️⃣ 巧妙的方法来了：**末端对齐（双指针切换）**

- 让两个人走完自己链表后，直接跳到另一个链表的头。

- 也就是：

  - P1 走完 A -> 走 B
  - P2 走完 B -> 走 A

- 这样两个指针走的路程都是 

  ```
  m + n
  ```

  - 如果有交点，最终会在相交点相遇
  - 如果没有交点，最终一起走到 null

**为什么这样就能对齐**？

举个例子：

```
链表A: a1 → a2 → c1 → c2 → c3
链表B: b1 → b2 → b3 → c1 → c2 → c3
```

- A 长度：5（2 + 3）
- B 长度：6（3 + 3）
- 交点 c1，公共长度 3

两人同时出发：

- P1 先走 A，走完 a1, a2, c1, c2, c3，然后去 B 走 b1, b2, b3
- P2 先走 B，走完 b1, b2, b3, c1, c2, c3，然后去 A 走 a1, a2

两个人在走 `m + n` 路程的过程中，会刚好在 c1 交汇（如果有交点），或者同时到达 null（如果没交点）。

{这样走,他们都是走的各自私有部分的和以及一次公共部分}

🔥 最终代码：

```cpp
ListNode* getIntersectionNode(ListNode *headA, ListNode *headB) {
    if (!headA || !headB) return nullptr;
    ListNode *p1 = headA;
    ListNode *p2 = headB;
    while (p1 != p2) {
        p1 = p1 ? p1->next : headB;
        p2 = p2 ? p2->next : headA;
    }
    return p1;  // 或 p2
}
```

## 环形链表Ⅱ

**索引+(实现)**

1. 是否环形

   - 快慢指针,相遇了就是有环.(为什么这样一定会相遇),随着进行,两个指针都会进入环内(如果有环的话),然后就是一个追击问题,所以是一定能追上的

2. 起点在哪里

   - 合理给链表分段![img](https://ycw-bucket1.oss-cn-beijing.aliyuncs.com/20220925103433.png)

     分别表述slow和fast指针走过的路程,寻找等量关系,然后表示x(因为这样分段之后x就是环开始的索引)

     得到等量关系`x = (n - 1) (y + z) + z`,先理解`n=1`,意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。

     当 n为1的时候，公式就化解为 `x = z`，这就意味着，**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。

     其实`n>1`的情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，(index在转的时候,index2正在赶来的路上)相遇点依然是环形的入口节点。

# 哈希表

## 理论基础

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 | 特点       |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- | ---------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) | 有序       |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  | 有重复数据 |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     | 普通集合   |

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 | 特点       |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- | ---------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |            |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |            |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     | 普通键值对 |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

## 有效的字母异位词

**索引**

数组其实就是一个哈希表,(你可以通过索引快速的找到对应的值)

另外,其实你只需要求一个相对数值就行了,这里的相对一个是指索引不用一定是‘a’而可以是`t[i]-'a'`;另一个是说不需要用两个数组分别放两个字符串对应字符的个数,只需要最后的结果是不是全0就可以了(详细方法见下面的优化)

**优化**

只用一个数组,先过一个字符串同时相应`++`,再过一个字符串相应`--`,这样如果最后就相消为0的话,那就是异位的

**注意**

**使用数组来做哈希的题目，是因为题目都限制了数值的大小。**如果题目没有限制数值的大小，就无法使用数组来做哈希表了。因为**如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。**

## 两个数组的交集

**索引**

这道题没什么可说的就是一个c++的set的应用

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // 存放结果，之所以用set是为了给结果集去重
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for (int num : nums2) {
            // 发现nums2的元素 在nums_set里又出现过
            if (nums_set.find(num) != nums_set.end()) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

## 快乐数

**索引**

因为又无限循环,那我们就要考虑是否会出现无限不循环的情景,但是题目中说了只有两种可能,那这个就不想了.然后处理无限循环,就是想到set中无重复,那就是每次算sum,然后判断是否在set中

**实现**

1. 做和部分

   因为不知道数字有几位,所以只能循环累加,每次循环处理一位数

2. 判断是否无限循环

   维护一个set,每次先判断再加进去(或者return false),剩下就是一个比较简单的循环了

## 两数之和

**索引**

**什么时候使用哈希法**，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。

map和set都有哈希特性,但是因为题目要求的是返回两个数字的下标,所以要记录两者的在数组中的索引,但是我们算法中判断是否存在是看数组的元素(也就是数字本身),所以我们有两个需要记录的量,所以我们选择使用map

**注意**

这道题的key应该是数组的元素(内容),value应该是数组的索引,因为value才是最终return所需要的值

**实现**

cpp中map的元素都是`pair`

## 四数相加II

**我的思路**

这纯回溯问题啊,遍历所有可能,一般看能不能回溯,我认为要先粗略的算一下时间复杂度(好像是500的四次),不过一般需要回溯的题目,就会让你返回一个包含所有要求的集合,而一般有技巧的题目,就会让你返回数量

**索引**

**前一半枚举进哈希表，后一半直接查找匹配**==非常重要的分组思维==

**(GPT给出的思维过程)**

太喜欢你这个提问方式了！这就是学会「**算法思维过程**」的关键步骤。
 这道题目叫 **"4Sum II"**，很经典。接下来我带你走一遍“正常人做题的思路 + 试错 + 碰壁 + 优化”的完整过程。

------

🔎 **第一步：最直接的暴力思路**

【想法】

题目问 `(i, j, k, l)` 满足 `A[i] + B[j] + C[k] + D[l] == 0`

- i、j、k、l 都独立，可以四层循环，把所有可能列出来
- 每找到一组符合的就 `count++`

【代码雏形】

```cpp
int count = 0;
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
        for (int k = 0; k < N; k++) {
            for (int l = 0; l < N; l++) {
                if (A[i] + B[j] + C[k] + D[l] == 0) count++;
            }
        }
    }
}
```

【试错点】

- 时间复杂度 `O(N^4)`
- N最大500 → 500⁴ = 6250亿次循环
- 明显超时！暴力直接死！

------

🔄 **第二步：尝试优化——分组 + 预处理**

【灵感来源】

- 想到：`A[i] + B[j] + C[k] + D[l] == 0` 可以拆成两部分
- `(A[i] + B[j]) + (C[k] + D[l]) == 0`
- 如果能先算出 `A[i] + B[j]` 所有可能，然后去查找 `-(C[k] + D[l])`，问题会简单很多！

【核心突破】

- 构建 `unordered_map<int, int>`，key 是 `A[i] + B[j]` 的和，value 是出现的次数（因为可能有重复）
- 再枚举 `C[k] + D[l]`，每算一个就看 `-(C[k] + D[l])` 是否在 map 里

------

🔥 **第三步：算算复杂度**

- `A[i] + B[j]` 枚举一遍：`O(N^2)`
- `C[k] + D[l]` 再枚举一遍：`O(N^2)`
- 查询 map 是 `O(1)`
- 总复杂度 `O(N^2) + O(N^2) = O(N^2)`，完美解决500的数据量！

------

💡 **第四步：模拟试错版本**

假设：

A = [1, 2], B = [-2, -1], C = [-1, 2], D = [0, 2]

先处理 `A + B`:

- 1 + (-2) = -1
- 1 + (-1) = 0
- 2 + (-2) = 0
- 2 + (-1) = 1

结果：

```
sumAB = {
  -1: 1,
   0: 2,
   1: 1
}
```

再处理 `C + D` 并查 map:

- -1 + 0 = -1 → 看 `1` 是否在 `sumAB`
- -1 + 2 = 1 → 看 `-1` 是否在 `sumAB`
- 2 + 0 = 2 → 看 `-2` 是否在 `sumAB`
- 2 + 2 = 4 → 看 `-4` 是否在 `sumAB`

查到的部分：

- -1 在 `sumAB`，有1个 → 计数 +1
- 1 在 `sumAB`，有1个 → 计数 +1

最终答案：2

------

✍ **第五步：总结一般解题套路（非常重要）**

| 阶段          | 做法                                | 典型思路         |
| ------------- | ----------------------------------- | ---------------- |
| 1. 暴力尝试   | 四层循环，发现复杂度炸了            | 暴力总是第一想法 |
| 2. 分组降维   | 发现可以 `(A+B)` `(C+D)` 分组       | 分组思想         |
| 3. 哈希优化   | 用 map 统计出现次数，反查匹配       | 空间换时间       |
| 4. 时间复杂度 | 优化到 O(N^2)                       | 可接受           |
| 5. 通用套路   | 多数求和问题可尝试「分组 + 哈希表」 | nSum问题         |

------

🧠 **这题的本质**

- 本质上是**「四数之和等于0」的计数问题**
- 通用解法：**前一半枚举进哈希表，后一半直接查找匹配**
- 扩展题目也能用类似思路做

# 做题

## 数据类型

int的上限是$2^{31}$,大约等于$2 \times 10^9$(前者稍稍大一点)

## IO

1. `cout << nums << endl;`

   `nums` 是一个二维 `vector`，不能直接使用 `cout` 输出。若要输出二维 `vector`，需通过嵌套循环遍历每个元素。

2. 