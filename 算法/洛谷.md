# 刷题

## 过河卒

**问题**

1. `fx`和`fy`数组定义了马可以跳到的相对位置，包括马本身的位置==（防止马在边界时数组越界）==。*{防止越界不应该是用判断和边界大小比大小么?给一个相对位置数组有什么用?}*

   - 防止越界的目的是确保在访问数组时不会出现索引超出数组边界的情况。在这段代码中，通过将所有坐标都加2，==**实际上是在原棋盘的周围添加了一个边界**==，这样在访问马的控制点时，即使是最边缘的点，也不会超出数组的边界。这种方法简化了边界条件的判断，因为不需要在每次计算时都检查是否越界。

2. `bx`, `by`是卒的终点坐标，`mx`, `my`是马的位置坐标。==输入这些坐标后，代码中将它们各自加2，这是为了在动态规划数组中留出边界==，避免处理边界情况时的复杂性。*{没有理解什么叫留出边界,如果处理边界是怎样的,如果按照这样的设计,有方便在哪里了}*

   - 留出边界是指在实际的棋盘周围**添加一圈不可达的点**，这样在动态规划计算时，就不需要特别处理边缘点的情况。{这个和上面的+2是一个意义吗?}
   - 如果不这样做，那么在计算边缘点的路径数量时，需要特别判断是否越界，这会增加代码的复杂性。
   - 这种设计方便之处在于，它统一了所有点的处理方式，无论是边缘点还是内部点，都可以使用相同的状态转移方程进行计算。

3. ==初始化`f[2][1] = 1`==，表示起点到起点的路径数量为1。*{起点的坐标为什么是这样的?}*

   - 起点的坐标被设置为`f[2][1]`是因为在代码中，所有的坐标都被加2以留出边界。因此，实际的起点==A(0,0)在数组中对应的位置是`f[2][1]`==。{都加2,不应该是`[2][2]`么?

     - 我的疑问是正确的,但是我没有理解这个(2,1)想要变大的意思

     - 这涉及到后续的二重遍历,如果想==**把这个点也当作正常点处理(将规律贯彻到底)**==的话,它需要有一个先验的条件,也就是(2,2)依赖的点,你初始化(2,1)和(1,2)都是可以的

       ```
       当然如果只是按照这个公式推肯定不行，因为 f 的初始数值都是 0，再怎么推也都是 0，我们要让 f(1,1) 能根据上面得到的式子推出答案是 1，这样才能有有意义的结果。根据 f(1,1)=f(0,1)+f(1,0)，我们只需要让 f(1,0)=1 或者 f(0,1)=1 即可。
       ```

       

4. 为什么没有对dp的数组做初始化?(数组应该初始化为0)

   - 在这段代码中，DP数组`f`没有显式初始化，==**这是因为C++中全局数组默认初始化为0**==。由于路径数量不可能为负，且只有当点可达时才会更新`f`数组的值，所以未更新的点默认为0是合理的。
   - ~~另外，代码中通过`if(s[i][j]) continue;`跳过了所有被马控制的点，这些点的路径数量自然应该是0，因为卒无法通过这些点。~~

**实现细节**

- 专门设置了一个bool数组,判断这个点是否被马控制
- 初始化全0